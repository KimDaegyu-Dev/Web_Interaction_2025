# InfiniteBackground 프로젝션 및 좌표계 문제 해결 보고서

## 1. 문제 상황
- `InfiniteBackground`의 직소 퍼즐 패턴이 `useGridInteraction`(마우스 레이캐스팅)이 인식하는 그리드 좌표와 일치하지 않음.
- 시각적으로 배경이 다른 객체들과 다른 평면에 있거나, 투영이 어긋난 것처럼 느껴짐 (이질감).

## 2. 원인 분석
### A. 좌표계 불일치
- `InfiniteBackground`는 `planeGeometry`를 사용하는데, 이는 기본적으로 **XY 평면**에 생성됩니다.
- 반면, 씬의 바닥은 **XZ 평면**입니다.
- 이를 맞추기 위해 지오메트리를 X축으로 -90도 회전시켰으나, 이로 인해 `ObliqueCamera`의 투영 행렬(`obliqueMatrix`)이 예상과 다르게 적용되었습니다.
    - `obliqueMatrix`는 (x, y, z) 입력을 기대하지만, 회전된 메쉬는 (x, z, -y) 형태의 좌표를 가집니다.
    - 결과적으로 높이(Y)에 적용되어야 할 비틀림이 깊이(Z)에 적용되는 등 축이 꼬였습니다.

### B. 패턴 왜곡
- 쉐이더에서 패턴을 그리기 위한 좌표(`vWorldPos`)를 계산할 때, `modelMatrix`가 적용된 후의 좌표(`worldPosition`)를 사용했습니다.
- `modelMatrix`(=`obliqueMatrix`)에는 **비틀림(Shear)**과 **이동(Translation)**이 포함되어 있습니다.
- 이로 인해 직소 퍼즐 패턴 자체가 비틀어지고, 메쉬가 이동할 때 패턴도 같이 이동하여 "월드에 고정된 바닥" 느낌이 나지 않았습니다.

## 3. 해결 방법
### A. 행렬 컬럼 스왑 (Matrix Column Swapping)
- 지오메트리를 물리적으로 회전시키는 대신, **투영 행렬을 조작**하여 좌표계를 맞췄습니다.
- `planeGeometry`는 XY 평면(x, y)을 가집니다. 이를 월드 XZ 평면(x, z)으로 매핑하기 위해, `obliqueMatrix`의 **Y열(2번째 열)과 Z열(3번째 열)을 서로 바꿨습니다.**
    - Mesh X (Col 0) -> World X
    - Mesh Y (Col 1) -> World Z (원래 Z열이었던 것이 Y열로 옴)
    - Mesh Z (Col 2) -> World Y (원래 Y열이었던 것이 Z열로 감)
- 이로 인해 메쉬의 2차원 평면이 월드의 바닥 평면으로 완벽하게 투영되었습니다.

### B. 로컬 좌표 사용 (Undistorted Coordinates)
- 쉐이더에서 패턴을 생성할 때, 비틀림이 적용된 `worldPosition` 대신 **비틀림 없는 로컬 좌표(`position.xy`)**를 사용했습니다.
- 행렬 스왑 덕분에 `position.x`는 월드 X, `position.y`는 월드 Z와 1:1로 대응됩니다.
- 이를 통해 패턴은 비틀어지지 않은 정직한 격자 형태를 유지하면서, 렌더링될 때만 투영에 맞춰 기울어지게 되었습니다.
- 결과적으로 `useGridInteraction`의 논리적 좌표계와 시각적 패턴이 완벽하게 일치하게 되었습니다.
직소 퍼즐 마이그레이션 보고서
1. 개요
본 문서는 그리드 기반 건물 배치 시스템을 직소 퍼즐 메시지 보드 시스템으로 마이그레이션하는 과정에서 발생한 이슈, 원인, 그리고 해결 방법을 정리한 보고서입니다.

2. 주요 이슈 및 해결 과정
이슈 1: 리플(Ripple) 이펙트가 보이지 않음
증상: 퍼즐 조각을 클릭했을 때 기대했던 물결 효과(Ripple Effect)가 나타나지 않음.
원인: 쉐이더에 전달되는 uClickTime과 uTime의 동기화 문제. uClickTime은 자바스크립트의 Date.now() 또는 performance.now() 기준이었으나, 쉐이더의 uTime은 state.clock.elapsedTime (Three.js clock) 기준이어서 시간 차이가 발생함.
해결: 클릭 이벤트 발생 시 state.clock.elapsedTime을 캡처하여 uClickTime으로 전달함으로써 시간 기준을 통일함.
이슈 2: 그리드와 퍼즐 조각의 스케일 불일치 (1:4 비율)
증상: 하나의 직소 퍼즐 조각이 4개의 그리드 셀을 차지하는 현상 발생.
원인: 직소 퍼즐 알고리즘(jigsaw.glsl)이 내부적으로 2x2 단위의 그리드를 하나의 패턴 단위로 사용하기 때문. 기본 UV 매핑(1:1)을 사용할 경우, 그리드 셀 1개가 퍼즐의 1/4(단위 셀 1개)만 보여주게 됨.
해결: 쉐이더에서 UV 좌표를 2.0배 스케일링(uv * 2.0)하여, 하나의 그리드 셀이 2x2 단위(즉, 하나의 완성된 퍼즐 조각)를 포함하도록 조정함.
이슈 3: 메시지 위치 불일치 및 하이라이팅 스킵 (체커보드 현상)
증상:
메시지를 남긴 위치와 실제 색상이 칠해지는 퍼즐 조각의 위치가 다름.
마우스 호버 시 하이라이팅이 체커보드 패턴처럼 일부 셀(0,0 등)에서 작동하지 않음.
원인:
회전(Rotation): 기존 쉐이더에 있던 45도 회전 로직(rotate45)이 직소 퍼즐의 좌표계와 그리드 좌표계를 어긋나게 만듦. 직소 퍼즐의 기본 형태가 다이아몬드 꼴이라 회전을 통해 사각형으로 맞추려 했으나, 이로 인해 그리드 코너가 퍼즐 조각의 경계에 걸치거나 벗어나는 문제 발생.
모양(Shape): 직소 퍼즐 알고리즘이 사용하는 기본 도형이 '다이아몬드(L1 Norm)' 형태임. 이를 사각형 그리드에 1:1로 매핑하려다 보니, 그리드 셀의 모서리 부분이 인접한 다른 퍼즐 조각의 영역으로 인식됨. 이로 인해 그리드 중심(Center)과 코너(Corner)의 소속 조각 ID가 달라져 하이라이팅 및 텍스처 매핑 오류 발생.
해결 (예정):
회전 제거: 45도 회전 로직을 완전히 제거하여 좌표계를 단순화.
도형 변경: jigsaw.glsl의 도형 함수를 다이아몬드(p.x + p.y)에서 정사각형(max(p.x, p.y))으로 변경. 이를 통해 퍼즐 조각이 그리드 셀을 빈틈없이 꽉 채우도록 하여, 그리드 셀 하나가 정확히 하나의 퍼즐 조각과 1:1로 대응되도록 수정.
3. 결론
초기에는 시각적 효과를 위해 회전과 다이아몬드 형태를 사용했으나, 이는 정직한 그리드 상호작용(1 Cell = 1 Piece)과 충돌을 일으켰습니다. 최종적으로 "형태를 그리드에 맞추는(Square Shape)" 접근 방식을 통해 시각적 아름다움과 상호작용의 정확성을 모두 확보할 수 있습니다.